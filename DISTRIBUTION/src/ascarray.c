/* Generated by Cython 0.9.6.14 on Mon Jun 22 15:37:06 2009 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)
  #define PyNumber_Index(o)    PyNumber_Int(o)
  #define PyIndex_Check(o)     PyNumber_Check(o)
#endif
#if PY_VERSION_HEX < 0x02040000
  #define METH_COEXIST 0
#endif
#ifndef __stdcall
  #define __stdcall
#endif
#ifndef __cdecl
  #define __cdecl
#endif
#ifdef __cplusplus
#define __PYX_EXTERN_C extern "C"
#else
#define __PYX_EXTERN_C extern
#endif
#include <math.h>
#include "numpy/arrayobject.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"


#ifdef __GNUC__
#define INLINE __inline__
#elif _WIN32
#define INLINE __inline
#else
#define INLINE 
#endif

typedef struct {PyObject **p; char *s;} __Pyx_InternTabEntry; /*proto*/
typedef struct {PyObject **p; char *s; long n; int is_unicode;} __Pyx_StringTabEntry; /*proto*/



static int __pyx_skip_dispatch = 0;


/* Type Conversion Predeclarations */

#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static INLINE int __Pyx_PyObject_IsTrue(PyObject* x);
static INLINE PY_LONG_LONG __pyx_PyInt_AsLongLong(PyObject* x);
static INLINE unsigned PY_LONG_LONG __pyx_PyInt_AsUnsignedLongLong(PyObject* x);
static INLINE Py_ssize_t __pyx_PyIndex_AsSsize_t(PyObject* b);

#define __pyx_PyInt_AsLong(x) (PyInt_CheckExact(x) ? PyInt_AS_LONG(x) : PyInt_AsLong(x))
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))

static INLINE unsigned char __pyx_PyInt_unsigned_char(PyObject* x);
static INLINE unsigned short __pyx_PyInt_unsigned_short(PyObject* x);
static INLINE char __pyx_PyInt_char(PyObject* x);
static INLINE short __pyx_PyInt_short(PyObject* x);
static INLINE int __pyx_PyInt_int(PyObject* x);
static INLINE long __pyx_PyInt_long(PyObject* x);
static INLINE signed char __pyx_PyInt_signed_char(PyObject* x);
static INLINE signed short __pyx_PyInt_signed_short(PyObject* x);
static INLINE signed int __pyx_PyInt_signed_int(PyObject* x);
static INLINE signed long __pyx_PyInt_signed_long(PyObject* x);
static INLINE long double __pyx_PyInt_long_double(PyObject* x);
#ifdef __GNUC__
/* Test for GCC > 2.95 */
#if __GNUC__ > 2 ||               (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)) 
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#else /* __GNUC__ > 2 ... */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static char * __pyx_cfilenm= __FILE__;
static char *__pyx_filename;
static char **__pyx_f;

static char __pyx_mdoc[] = "\n================\nModule ascarray\n================\n\nThis module is the base containing the function on which :mod:`tabarray`\nhas been built.\n\nFunction ascarray\n-----------------\n\n.. autofunction:: ascarray(filename[, comchar=\'#!\', sepchar=\', \\\\t\', lines=None, bad=None])\n\n";

static INLINE void __Pyx_RaiseArgtupleTooLong(Py_ssize_t num_expected, Py_ssize_t num_found); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list); /*proto*/

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb); /*proto*/

static PyObject *__Pyx_UnpackItem(PyObject *, Py_ssize_t index); /*proto*/
static int __Pyx_EndUnpack(PyObject *); /*proto*/

static int __Pyx_InternStrings(__Pyx_InternTabEntry *t); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/

static void __Pyx_AddTraceback(char *funcname); /*proto*/

/* Declarations */

typedef void __pyx_t_8ascarray_FILE;



/* Implementation of ascarray */

static char __pyx_k_2[] = "#!";
static char __pyx_k_3[] = ", \t";
static char __pyx_k_4[] = "1.1";

static PyObject *__pyx_n_numpy;
static PyObject *__pyx_n___version__;

static PyObject *__pyx_k_3p;
static PyObject *__pyx_k_4p;

/* "/Users/users/terlouw/Python/Tables/ascarray.pyx":62
 * #  Read an ASCII table file and return its data as a NumPy array.
 * #
 * def ascarray(filename, char *comchar='#!', sepchar=', \t', lines=None, bad=None):             # <<<<<<<<<<<<<< 
 *    """
 * Read an ASCII table file and return its data as a NumPy array.
 */

static PyObject *__pyx_n_IOError;
static PyObject *__pyx_n_IndexError;
static PyObject *__pyx_n_ValueError;
static PyObject *__pyx_n_shape;

static PyObject *__pyx_k_6p;
static PyObject *__pyx_k_7p;
static PyObject *__pyx_k_8p;
static PyObject *__pyx_k_9p;
static PyObject *__pyx_k_10p;

static PyObject *__pyx_builtin_IOError;
static PyObject *__pyx_builtin_IndexError;
static PyObject *__pyx_builtin_ValueError;

static char __pyx_k_5[] = "r";
static char __pyx_k_6[] = "cannot open %s";
static char __pyx_k_7[] = "\n";
static char __pyx_k_8[] = "%s, line %d: column width error";
static char __pyx_k_9[] = "%s, line %d, column %d: invalid number \"%s\"";
static char __pyx_k_10[] = "%s: no lines of data read";

static PyObject *__pyx_pf_8ascarray_ascarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_8ascarray_ascarray[] = "\nRead an ASCII table file and return its data as a NumPy array.\n\n:param source:\n   a string with the name of a text file containing the table.\n:param comchar:\n   string with characters which are used to designate\n   comments in the input file.  The occurrence of any of these\n   characters on a line causes the rest of the line to be ignored.\n   Empty lines and lines containing only a comment are also ignored.\n   Default: \'#!\'.\n:param sepchar:\n   a string containing the column separation characters to be used.\n   Columns are separated by any combination of these characters.\n   Default: \', \\\\t\'.\n:param lines:\n   a two-element tuple or list specifying a range of lines to be\n   read.  Line numbers are counted from one and the range is\n   inclusive.  So (1,10) specifies the first 10 lines of a file. \n   Comment lines are included in the count.  If any element of\n   the tuple or list is zero, this limit is ignored. So (1,0)\n   specifies the whole file, just like the default None. \n   Default: all lines.\n:param bad:\n   a number to be substituted for any field which cannot be\n   decoded as a number. The default None causes a :exc:`ValueError`\n   exception to be raised in such cases.\n:returns:\n   a NumPy array containing the selected data from the table file.\n:raises:\n   :exc:`IOError`, when the file cannot be opened.\n\n   :exc:`IndexError`, when a line with an inconsistent number of fields is\n   encountered in the input file.\n\n   :exc:`ValueError`: when a field cannot be decoded as a number and\n   no alternative value was specified.\n\n";
static PyObject *__pyx_pf_8ascarray_ascarray(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_filename = 0;
  char *__pyx_v_comchar;
  PyObject *__pyx_v_sepchar = 0;
  PyObject *__pyx_v_lines = 0;
  PyObject *__pyx_v_bad = 0;
  __pyx_t_8ascarray_FILE *__pyx_v_f;
  char __pyx_v_line[32768];
  char *__pyx_v_tokens[10000];
  char *__pyx_v_curline;
  char *__pyx_v_token;
  char *__pyx_v_comstart;
  char *__pyx_v_csep;
  char *__pyx_v_endptr;
  int __pyx_v_i;
  int __pyx_v_column;
  int __pyx_v_ncols;
  int __pyx_v_lineno;
  int __pyx_v_lstart;
  int __pyx_v_lend;
  npy_intp __pyx_v_nvalues;
  int __pyx_v_filesize;
  int __pyx_v_maxitems;
  int __pyx_v_badflag;
  double *__pyx_v_data;
  double __pyx_v_badvalue;
  PyObject *__pyx_v_result;
  PyObject *__pyx_r;
  char *__pyx_1;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  int __pyx_4;
  double __pyx_5;
  PyObject *__pyx_6 = 0;
  long __pyx_7;
  PyObject *__pyx_8 = 0;
  PyObject *__pyx_9 = 0;
  static char *__pyx_argnames[] = {"filename","comchar","sepchar","lines","bad",0};
  __pyx_v_comchar = __pyx_k_2;
  __pyx_v_sepchar = __pyx_k_3p;
  __pyx_v_lines = Py_None;
  __pyx_v_bad = Py_None;
  if (likely(!__pyx_kwds) && likely(1 <= PyTuple_GET_SIZE(__pyx_args)) && likely(PyTuple_GET_SIZE(__pyx_args) <= 5)) {
    __pyx_v_filename = PyTuple_GET_ITEM(__pyx_args, 0);
    if (PyTuple_GET_SIZE(__pyx_args) > 1) {
      __pyx_v_comchar = PyString_AsString(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((!__pyx_v_comchar) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L2;}
      if (PyTuple_GET_SIZE(__pyx_args) > 2) {
        __pyx_v_sepchar = PyTuple_GET_ITEM(__pyx_args, 2);
        if (PyTuple_GET_SIZE(__pyx_args) > 3) {
          __pyx_v_lines = PyTuple_GET_ITEM(__pyx_args, 3);
          if (PyTuple_GET_SIZE(__pyx_args) > 4) {
            __pyx_v_bad = PyTuple_GET_ITEM(__pyx_args, 4);
          }
        }
      }
    }
  }
  else {
    if (unlikely(!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "O|sOOO", __pyx_argnames, &__pyx_v_filename, &__pyx_v_comchar, &__pyx_v_sepchar, &__pyx_v_lines, &__pyx_v_bad))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L2;}
  }
  goto __pyx_L3;
  __pyx_L2:;
  __Pyx_AddTraceback("ascarray.ascarray");
  return NULL;
  __pyx_L3:;
  Py_INCREF(__pyx_v_sepchar);
  __pyx_v_result = Py_None; Py_INCREF(Py_None);

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":107
 *    cdef char *curline, *token, *comstart, *csep
 *    cdef char *endptr
 *    cdef int i, column, ncols=0, lineno=0, lstart=0, lend=0             # <<<<<<<<<<<<<< 
 *    cdef npy_intp nvalues=0
 *    cdef int filesize, maxitems, badflag
 */
  __pyx_v_ncols = 0;

  __pyx_v_lineno = 0;

  __pyx_v_lstart = 0;

  __pyx_v_lend = 0;


  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":108
 *    cdef char *endptr
 *    cdef int i, column, ncols=0, lineno=0, lstart=0, lend=0
 *    cdef npy_intp nvalues=0             # <<<<<<<<<<<<<< 
 *    cdef int filesize, maxitems, badflag
 *    cdef double *data=NULL, badvalue
 */
  __pyx_v_nvalues = 0;


  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":110
 *    cdef npy_intp nvalues=0
 *    cdef int filesize, maxitems, badflag
 *    cdef double *data=NULL, badvalue             # <<<<<<<<<<<<<< 
 *    f = fopen(filename, "r")
 *    if f==NULL:
 */
  __pyx_v_data = NULL;


  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":111
 *    cdef int filesize, maxitems, badflag
 *    cdef double *data=NULL, badvalue
 *    f = fopen(filename, "r")             # <<<<<<<<<<<<<< 
 *    if f==NULL:
 *       raise IOError, 'cannot open %s' % filename
 */
  __pyx_1 = PyString_AsString(__pyx_v_filename); if (unlikely((!__pyx_1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 111; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_v_f = fopen(__pyx_1, __pyx_k_5);

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":112
 *    cdef double *data=NULL, badvalue
 *    f = fopen(filename, "r")
 *    if f==NULL:             # <<<<<<<<<<<<<< 
 *       raise IOError, 'cannot open %s' % filename
 *    fseek(f, 0, SEEK_END)
 */
  __pyx_2 = (__pyx_v_f == NULL);
  if (__pyx_2) {

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":113
 *    f = fopen(filename, "r")
 *    if f==NULL:
 *       raise IOError, 'cannot open %s' % filename             # <<<<<<<<<<<<<< 
 *    fseek(f, 0, SEEK_END)
 *    filesize = ftell(f)
 */
    __pyx_3 = PyNumber_Remainder(__pyx_k_6p, __pyx_v_filename); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 113; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __Pyx_Raise(__pyx_builtin_IOError, __pyx_3, 0);
    Py_DECREF(__pyx_3); __pyx_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 113; __pyx_clineno = __LINE__; goto __pyx_L1;}
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":114
 *    if f==NULL:
 *       raise IOError, 'cannot open %s' % filename
 *    fseek(f, 0, SEEK_END)             # <<<<<<<<<<<<<< 
 *    filesize = ftell(f)
 *    fseek(f, 0, SEEK_SET)
 */
  fseek(__pyx_v_f, 0, SEEK_END);

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":115
 *       raise IOError, 'cannot open %s' % filename
 *    fseek(f, 0, SEEK_END)
 *    filesize = ftell(f)             # <<<<<<<<<<<<<< 
 *    fseek(f, 0, SEEK_SET)
 *    sepchar += '\n'
 */
  __pyx_v_filesize = ftell(__pyx_v_f);

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":116
 *    fseek(f, 0, SEEK_END)
 *    filesize = ftell(f)
 *    fseek(f, 0, SEEK_SET)             # <<<<<<<<<<<<<< 
 *    sepchar += '\n'
 *    csep = sepchar
 */
  fseek(__pyx_v_f, 0, SEEK_SET);

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":117
 *    filesize = ftell(f)
 *    fseek(f, 0, SEEK_SET)
 *    sepchar += '\n'             # <<<<<<<<<<<<<< 
 *    csep = sepchar
 *    badflag = bad is not None
 */
  __pyx_3 = PyNumber_InPlaceAdd(__pyx_v_sepchar, __pyx_k_7p); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_v_sepchar);
  __pyx_v_sepchar = __pyx_3;
  __pyx_3 = 0;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":118
 *    fseek(f, 0, SEEK_SET)
 *    sepchar += '\n'
 *    csep = sepchar             # <<<<<<<<<<<<<< 
 *    badflag = bad is not None
 *    if badflag:
 */
  __pyx_1 = PyString_AsString(__pyx_v_sepchar); if (unlikely((!__pyx_1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_v_csep = __pyx_1;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":119
 *    sepchar += '\n'
 *    csep = sepchar
 *    badflag = bad is not None             # <<<<<<<<<<<<<< 
 *    if badflag:
 *       badvalue = bad
 */
  __pyx_2 = (__pyx_v_bad != Py_None);
  __pyx_v_badflag = __pyx_2;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":120
 *    csep = sepchar
 *    badflag = bad is not None
 *    if badflag:             # <<<<<<<<<<<<<< 
 *       badvalue = bad
 *    if lines:
 */
  __pyx_4 = __pyx_v_badflag;
  if (__pyx_4) {

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":121
 *    badflag = bad is not None
 *    if badflag:
 *       badvalue = bad             # <<<<<<<<<<<<<< 
 *    if lines:
 *       lstart, lend = lines
 */
    __pyx_5 = __pyx_PyFloat_AsDouble(__pyx_v_bad); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __pyx_v_badvalue = __pyx_5;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":122
 *    if badflag:
 *       badvalue = bad
 *    if lines:             # <<<<<<<<<<<<<< 
 *       lstart, lend = lines
 *    while fgets(line, 32768, f) != NULL:
 */
  __pyx_2 = __Pyx_PyObject_IsTrue(__pyx_v_lines); if (unlikely(__pyx_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 122; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (__pyx_2) {

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":123
 *       badvalue = bad
 *    if lines:
 *       lstart, lend = lines             # <<<<<<<<<<<<<< 
 *    while fgets(line, 32768, f) != NULL:
 *       lineno += 1
 */
    if (PyTuple_CheckExact(__pyx_v_lines) && PyTuple_GET_SIZE(__pyx_v_lines) == 2) {
      PyObject* tuple = __pyx_v_lines;
      __pyx_6 = PyTuple_GET_ITEM(tuple, 0);
      Py_INCREF(__pyx_6);
      __pyx_4 = __pyx_PyInt_int(__pyx_6); if (unlikely((__pyx_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(__pyx_6); __pyx_6 = 0;
      __pyx_v_lstart = __pyx_4;
      __pyx_6 = PyTuple_GET_ITEM(tuple, 1);
      Py_INCREF(__pyx_6);
      __pyx_4 = __pyx_PyInt_int(__pyx_6); if (unlikely((__pyx_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(__pyx_6); __pyx_6 = 0;
      __pyx_v_lend = __pyx_4;
    }
    else {
      __pyx_3 = PyObject_GetIter(__pyx_v_lines); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_6 = __Pyx_UnpackItem(__pyx_3, 0); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_4 = __pyx_PyInt_int(__pyx_6); if (unlikely((__pyx_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(__pyx_6); __pyx_6 = 0;
      __pyx_v_lstart = __pyx_4;
      __pyx_6 = __Pyx_UnpackItem(__pyx_3, 1); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      __pyx_4 = __pyx_PyInt_int(__pyx_6); if (unlikely((__pyx_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(__pyx_6); __pyx_6 = 0;
      __pyx_v_lend = __pyx_4;
      if (__Pyx_EndUnpack(__pyx_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1;}
      Py_DECREF(__pyx_3); __pyx_3 = 0;
    }
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":124
 *    if lines:
 *       lstart, lend = lines
 *    while fgets(line, 32768, f) != NULL:             # <<<<<<<<<<<<<< 
 *       lineno += 1
 *       if lstart>0 and lineno<lstart:
 */
  while (1) {
    __pyx_2 = (fgets(__pyx_v_line, 32768, __pyx_v_f) != NULL);
    if (!__pyx_2) break;

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":125
 *       lstart, lend = lines
 *    while fgets(line, 32768, f) != NULL:
 *       lineno += 1             # <<<<<<<<<<<<<< 
 *       if lstart>0 and lineno<lstart:
 *          continue
 */
    __pyx_v_lineno += 1;

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":126
 *    while fgets(line, 32768, f) != NULL:
 *       lineno += 1
 *       if lstart>0 and lineno<lstart:             # <<<<<<<<<<<<<< 
 *          continue
 *       if lend>0 and lineno>lend:
 */
    __pyx_2 = (__pyx_v_lstart > 0);
    if (__pyx_2) {
      __pyx_2 = (__pyx_v_lineno < __pyx_v_lstart);
    }
    if (__pyx_2) {
      goto __pyx_L7;
      goto __pyx_L9;
    }
    __pyx_L9:;

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":128
 *       if lstart>0 and lineno<lstart:
 *          continue
 *       if lend>0 and lineno>lend:             # <<<<<<<<<<<<<< 
 *          break
 *       comstart = strpbrk(line, comchar)
 */
    __pyx_2 = (__pyx_v_lend > 0);
    if (__pyx_2) {
      __pyx_2 = (__pyx_v_lineno > __pyx_v_lend);
    }
    if (__pyx_2) {
      goto __pyx_L8;
      goto __pyx_L10;
    }
    __pyx_L10:;

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":130
 *       if lend>0 and lineno>lend:
 *          break
 *       comstart = strpbrk(line, comchar)             # <<<<<<<<<<<<<< 
 *       if comstart!=NULL:
 *          comstart[0] = 0
 */
    __pyx_v_comstart = strpbrk(__pyx_v_line, __pyx_v_comchar);

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":131
 *          break
 *       comstart = strpbrk(line, comchar)
 *       if comstart!=NULL:             # <<<<<<<<<<<<<< 
 *          comstart[0] = 0
 *       column = 0
 */
    __pyx_2 = (__pyx_v_comstart != NULL);
    if (__pyx_2) {

      /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":132
 *       comstart = strpbrk(line, comchar)
 *       if comstart!=NULL:
 *          comstart[0] = 0             # <<<<<<<<<<<<<< 
 *       column = 0
 *       curline = line
 */
      (__pyx_v_comstart[0]) = 0;
      goto __pyx_L11;
    }
    __pyx_L11:;

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":133
 *       if comstart!=NULL:
 *          comstart[0] = 0
 *       column = 0             # <<<<<<<<<<<<<< 
 *       curline = line
 *       while 1:
 */
    __pyx_v_column = 0;

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":134
 *          comstart[0] = 0
 *       column = 0
 *       curline = line             # <<<<<<<<<<<<<< 
 *       while 1:
 *          token = strtok(curline, csep)
 */
    __pyx_v_curline = __pyx_v_line;

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":135
 *       column = 0
 *       curline = line
 *       while 1:             # <<<<<<<<<<<<<< 
 *          token = strtok(curline, csep)
 *          curline = NULL
 */
    while (1) {
      __pyx_7 = 1;
      if (!__pyx_7) break;

      /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":136
 *       curline = line
 *       while 1:
 *          token = strtok(curline, csep)             # <<<<<<<<<<<<<< 
 *          curline = NULL
 *          if token != NULL:
 */
      __pyx_v_token = strtok(__pyx_v_curline, __pyx_v_csep);

      /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":137
 *       while 1:
 *          token = strtok(curline, csep)
 *          curline = NULL             # <<<<<<<<<<<<<< 
 *          if token != NULL:
 *             tokens[column] = token
 */
      __pyx_v_curline = NULL;

      /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":138
 *          token = strtok(curline, csep)
 *          curline = NULL
 *          if token != NULL:             # <<<<<<<<<<<<<< 
 *             tokens[column] = token
 *             column += 1
 */
      __pyx_2 = (__pyx_v_token != NULL);
      if (__pyx_2) {

        /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":139
 *          curline = NULL
 *          if token != NULL:
 *             tokens[column] = token             # <<<<<<<<<<<<<< 
 *             column += 1
 *          else:
 */
        (__pyx_v_tokens[__pyx_v_column]) = __pyx_v_token;

        /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":140
 *          if token != NULL:
 *             tokens[column] = token
 *             column += 1             # <<<<<<<<<<<<<< 
 *          else:
 *             if column>0:
 */
        __pyx_v_column += 1;
        goto __pyx_L14;
      }
      /*else*/ {

        /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":142
 *             column += 1
 *          else:
 *             if column>0:             # <<<<<<<<<<<<<< 
 *                if ncols>0:
 *                   if ncols!=column:
 */
        __pyx_2 = (__pyx_v_column > 0);
        if (__pyx_2) {

          /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":143
 *          else:
 *             if column>0:
 *                if ncols>0:             # <<<<<<<<<<<<<< 
 *                   if ncols!=column:
 *                      fclose(f)
 */
          __pyx_2 = (__pyx_v_ncols > 0);
          if (__pyx_2) {

            /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":144
 *             if column>0:
 *                if ncols>0:
 *                   if ncols!=column:             # <<<<<<<<<<<<<< 
 *                      fclose(f)
 *                      raise IndexError, \
 */
            __pyx_2 = (__pyx_v_ncols != __pyx_v_column);
            if (__pyx_2) {

              /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":145
 *                if ncols>0:
 *                   if ncols!=column:
 *                      fclose(f)             # <<<<<<<<<<<<<< 
 *                      raise IndexError, \
 *                         '%s, line %d: column width error' % (filename, lineno)
 */
              fclose(__pyx_v_f);

              /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":147
 *                      fclose(f)
 *                      raise IndexError, \
 *                         '%s, line %d: column width error' % (filename, lineno)             # <<<<<<<<<<<<<< 
 *                else:
 *                   ncols = column
 */
              __pyx_6 = PyInt_FromLong(__pyx_v_lineno); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1;}
              __pyx_3 = PyTuple_New(2); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1;}
              Py_INCREF(__pyx_v_filename);
              PyTuple_SET_ITEM(__pyx_3, 0, __pyx_v_filename);
              PyTuple_SET_ITEM(__pyx_3, 1, __pyx_6);
              __pyx_6 = 0;
              __pyx_6 = PyNumber_Remainder(__pyx_k_8p, ((PyObject *)__pyx_3)); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1;}
              Py_DECREF(((PyObject *)__pyx_3)); __pyx_3 = 0;
              __Pyx_Raise(__pyx_builtin_IndexError, __pyx_6, 0);
              Py_DECREF(__pyx_6); __pyx_6 = 0;
              {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L1;}
              goto __pyx_L17;
            }
            __pyx_L17:;
            goto __pyx_L16;
          }
          /*else*/ {

            /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":149
 *                         '%s, line %d: column width error' % (filename, lineno)
 *                else:
 *                   ncols = column             # <<<<<<<<<<<<<< 
 *                   maxitems = <int>(1.3*ncols*filesize/strlen(line))+ncols
 *                   data = <double*>malloc(maxitems*sizeof(double))
 */
            __pyx_v_ncols = __pyx_v_column;

            /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":150
 *                else:
 *                   ncols = column
 *                   maxitems = <int>(1.3*ncols*filesize/strlen(line))+ncols             # <<<<<<<<<<<<<< 
 *                   data = <double*>malloc(maxitems*sizeof(double))
 *             for i from 0 <= i <column:
 */
            __pyx_v_maxitems = (((int)(((1.3 * __pyx_v_ncols) * __pyx_v_filesize) / strlen(__pyx_v_line))) + __pyx_v_ncols);

            /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":151
 *                   ncols = column
 *                   maxitems = <int>(1.3*ncols*filesize/strlen(line))+ncols
 *                   data = <double*>malloc(maxitems*sizeof(double))             # <<<<<<<<<<<<<< 
 *             for i from 0 <= i <column:
 *                if nvalues>=maxitems:
 */
            __pyx_v_data = ((double *)malloc((__pyx_v_maxitems * (sizeof(double)))));
          }
          __pyx_L16:;
          goto __pyx_L15;
        }
        __pyx_L15:;

        /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":152
 *                   maxitems = <int>(1.3*ncols*filesize/strlen(line))+ncols
 *                   data = <double*>malloc(maxitems*sizeof(double))
 *             for i from 0 <= i <column:             # <<<<<<<<<<<<<< 
 *                if nvalues>=maxitems:
 *                   maxitems = <int>(1.3*maxitems)+ncols
 */
        for (__pyx_v_i = 0; __pyx_v_i < __pyx_v_column; __pyx_v_i++) {

          /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":153
 *                   data = <double*>malloc(maxitems*sizeof(double))
 *             for i from 0 <= i <column:
 *                if nvalues>=maxitems:             # <<<<<<<<<<<<<< 
 *                   maxitems = <int>(1.3*maxitems)+ncols
 *                   data = <double*>realloc(data, maxitems*sizeof(double))
 */
          __pyx_2 = (__pyx_v_nvalues >= __pyx_v_maxitems);
          if (__pyx_2) {

            /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":154
 *             for i from 0 <= i <column:
 *                if nvalues>=maxitems:
 *                   maxitems = <int>(1.3*maxitems)+ncols             # <<<<<<<<<<<<<< 
 *                   data = <double*>realloc(data, maxitems*sizeof(double))
 *                data[nvalues] = strtod(tokens[i], &endptr)
 */
            __pyx_v_maxitems = (((int)(1.3 * __pyx_v_maxitems)) + __pyx_v_ncols);

            /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":155
 *                if nvalues>=maxitems:
 *                   maxitems = <int>(1.3*maxitems)+ncols
 *                   data = <double*>realloc(data, maxitems*sizeof(double))             # <<<<<<<<<<<<<< 
 *                data[nvalues] = strtod(tokens[i], &endptr)
 *                if endptr[0]!=0:
 */
            __pyx_v_data = ((double *)realloc(__pyx_v_data, (__pyx_v_maxitems * (sizeof(double)))));
            goto __pyx_L20;
          }
          __pyx_L20:;

          /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":156
 *                   maxitems = <int>(1.3*maxitems)+ncols
 *                   data = <double*>realloc(data, maxitems*sizeof(double))
 *                data[nvalues] = strtod(tokens[i], &endptr)             # <<<<<<<<<<<<<< 
 *                if endptr[0]!=0:
 *                   if badflag:
 */
          (__pyx_v_data[__pyx_v_nvalues]) = strtod((__pyx_v_tokens[__pyx_v_i]), (&__pyx_v_endptr));

          /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":157
 *                   data = <double*>realloc(data, maxitems*sizeof(double))
 *                data[nvalues] = strtod(tokens[i], &endptr)
 *                if endptr[0]!=0:             # <<<<<<<<<<<<<< 
 *                   if badflag:
 *                      data[nvalues] = badvalue
 */
          __pyx_2 = ((__pyx_v_endptr[0]) != 0);
          if (__pyx_2) {

            /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":158
 *                data[nvalues] = strtod(tokens[i], &endptr)
 *                if endptr[0]!=0:
 *                   if badflag:             # <<<<<<<<<<<<<< 
 *                      data[nvalues] = badvalue
 *                   else:
 */
            __pyx_4 = __pyx_v_badflag;
            if (__pyx_4) {

              /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":159
 *                if endptr[0]!=0:
 *                   if badflag:
 *                      data[nvalues] = badvalue             # <<<<<<<<<<<<<< 
 *                   else:
 *                      fclose(f)
 */
              (__pyx_v_data[__pyx_v_nvalues]) = __pyx_v_badvalue;
              goto __pyx_L22;
            }
            /*else*/ {

              /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":161
 *                      data[nvalues] = badvalue
 *                   else:
 *                      fclose(f)             # <<<<<<<<<<<<<< 
 *                      raise ValueError, \
 *                       '%s, line %d, column %d: invalid number "%s"' \
 */
              fclose(__pyx_v_f);

              /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":164
 *                      raise ValueError, \
 *                       '%s, line %d, column %d: invalid number "%s"' \
 *                       % (filename, lineno, i+1, tokens[i])             # <<<<<<<<<<<<<< 
 *                nvalues += 1
 *             break
 */
              __pyx_3 = PyInt_FromLong(__pyx_v_lineno); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1;}
              __pyx_6 = PyInt_FromLong((__pyx_v_i + 1)); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1;}
              __pyx_8 = PyString_FromString((__pyx_v_tokens[__pyx_v_i])); if (unlikely(!__pyx_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1;}
              __pyx_9 = PyTuple_New(4); if (unlikely(!__pyx_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1;}
              Py_INCREF(__pyx_v_filename);
              PyTuple_SET_ITEM(__pyx_9, 0, __pyx_v_filename);
              PyTuple_SET_ITEM(__pyx_9, 1, __pyx_3);
              PyTuple_SET_ITEM(__pyx_9, 2, __pyx_6);
              PyTuple_SET_ITEM(__pyx_9, 3, __pyx_8);
              __pyx_3 = 0;
              __pyx_6 = 0;
              __pyx_8 = 0;
              __pyx_3 = PyNumber_Remainder(__pyx_k_9p, ((PyObject *)__pyx_9)); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1;}
              Py_DECREF(((PyObject *)__pyx_9)); __pyx_9 = 0;
              __Pyx_Raise(__pyx_builtin_ValueError, __pyx_3, 0);
              Py_DECREF(__pyx_3); __pyx_3 = 0;
              {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1;}
            }
            __pyx_L22:;
            goto __pyx_L21;
          }
          __pyx_L21:;

          /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":165
 *                       '%s, line %d, column %d: invalid number "%s"' \
 *                       % (filename, lineno, i+1, tokens[i])
 *                nvalues += 1             # <<<<<<<<<<<<<< 
 *             break
 *    fclose(f)
 */
          __pyx_v_nvalues += 1;
        }

        /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":166
 *                       % (filename, lineno, i+1, tokens[i])
 *                nvalues += 1
 *             break             # <<<<<<<<<<<<<< 
 *    fclose(f)
 *    if not data:
 */
        goto __pyx_L13;
      }
      __pyx_L14:;
    }
    __pyx_L13:;
    __pyx_L7:;
  }
  __pyx_L8:;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":167
 *                nvalues += 1
 *             break
 *    fclose(f)             # <<<<<<<<<<<<<< 
 *    if not data:
 *       raise IndexError, '%s: no lines of data read' % filename
 */
  fclose(__pyx_v_f);

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":168
 *             break
 *    fclose(f)
 *    if not data:             # <<<<<<<<<<<<<< 
 *       raise IndexError, '%s: no lines of data read' % filename
 *    data = <double*>realloc(data, nvalues*sizeof(double))
 */
  __pyx_2 = (!(__pyx_v_data != 0));
  if (__pyx_2) {

    /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":169
 *    fclose(f)
 *    if not data:
 *       raise IndexError, '%s: no lines of data read' % filename             # <<<<<<<<<<<<<< 
 *    data = <double*>realloc(data, nvalues*sizeof(double))
 *    result = PyArray_SimpleNewFromData(1, &nvalues, NPY_DOUBLE, data)
 */
    __pyx_6 = PyNumber_Remainder(__pyx_k_10p, __pyx_v_filename); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1;}
    __Pyx_Raise(__pyx_builtin_IndexError, __pyx_6, 0);
    Py_DECREF(__pyx_6); __pyx_6 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1;}
    goto __pyx_L23;
  }
  __pyx_L23:;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":170
 *    if not data:
 *       raise IndexError, '%s: no lines of data read' % filename
 *    data = <double*>realloc(data, nvalues*sizeof(double))             # <<<<<<<<<<<<<< 
 *    result = PyArray_SimpleNewFromData(1, &nvalues, NPY_DOUBLE, data)
 *    result.shape = (nvalues/ncols, ncols)
 */
  __pyx_v_data = ((double *)realloc(__pyx_v_data, (__pyx_v_nvalues * (sizeof(double)))));

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":171
 *       raise IndexError, '%s: no lines of data read' % filename
 *    data = <double*>realloc(data, nvalues*sizeof(double))
 *    result = PyArray_SimpleNewFromData(1, &nvalues, NPY_DOUBLE, data)             # <<<<<<<<<<<<<< 
 *    result.shape = (nvalues/ncols, ncols)
 *    return result
 */
  __pyx_8 = PyArray_SimpleNewFromData(1, (&__pyx_v_nvalues), NPY_DOUBLE, __pyx_v_data); if (unlikely(!__pyx_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_v_result);
  __pyx_v_result = __pyx_8;
  __pyx_8 = 0;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":172
 *    data = <double*>realloc(data, nvalues*sizeof(double))
 *    result = PyArray_SimpleNewFromData(1, &nvalues, NPY_DOUBLE, data)
 *    result.shape = (nvalues/ncols, ncols)             # <<<<<<<<<<<<<< 
 *    return result
 * 
 */
  __pyx_9 = PyInt_FromLong((__pyx_v_nvalues / __pyx_v_ncols)); if (unlikely(!__pyx_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_3 = PyInt_FromLong(__pyx_v_ncols); if (unlikely(!__pyx_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_6 = PyTuple_New(2); if (unlikely(!__pyx_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1;}
  PyTuple_SET_ITEM(__pyx_6, 0, __pyx_9);
  PyTuple_SET_ITEM(__pyx_6, 1, __pyx_3);
  __pyx_9 = 0;
  __pyx_3 = 0;
  if (PyObject_SetAttr(__pyx_v_result, __pyx_n_shape, ((PyObject *)__pyx_6)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(((PyObject *)__pyx_6)); __pyx_6 = 0;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":173
 *    result = PyArray_SimpleNewFromData(1, &nvalues, NPY_DOUBLE, data)
 *    result.shape = (nvalues/ncols, ncols)
 *    return result             # <<<<<<<<<<<<<< 
 * 
 * __version__ = '1.1'
 */
  Py_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1:;
  Py_XDECREF(__pyx_3);
  Py_XDECREF(__pyx_6);
  Py_XDECREF(__pyx_8);
  Py_XDECREF(__pyx_9);
  __Pyx_AddTraceback("ascarray.ascarray");
  __pyx_r = NULL;
  __pyx_L0:;
  Py_DECREF(__pyx_v_result);
  Py_DECREF(__pyx_v_sepchar);
  return __pyx_r;
}

static __Pyx_InternTabEntry __pyx_intern_tab[] = {
  {&__pyx_n_IOError, "IOError"},
  {&__pyx_n_IndexError, "IndexError"},
  {&__pyx_n_ValueError, "ValueError"},
  {&__pyx_n___version__, "__version__"},
  {&__pyx_n_numpy, "numpy"},
  {&__pyx_n_shape, "shape"},
  {0, 0}
};

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_k_3p, __pyx_k_3, sizeof(__pyx_k_3), 0},
  {&__pyx_k_4p, __pyx_k_4, sizeof(__pyx_k_4), 0},
  {&__pyx_k_6p, __pyx_k_6, sizeof(__pyx_k_6), 0},
  {&__pyx_k_7p, __pyx_k_7, sizeof(__pyx_k_7), 0},
  {&__pyx_k_8p, __pyx_k_8, sizeof(__pyx_k_8), 0},
  {&__pyx_k_9p, __pyx_k_9, sizeof(__pyx_k_9), 0},
  {&__pyx_k_10p, __pyx_k_10, sizeof(__pyx_k_10), 0},
  {0, 0, 0, 0}
};

static struct PyMethodDef __pyx_methods[] = {
  {"ascarray", (PyCFunction)__pyx_pf_8ascarray_ascarray, METH_VARARGS|METH_KEYWORDS, __pyx_doc_8ascarray_ascarray},
  {0, 0, 0, 0}
};

static void __pyx_init_filenames(void); /*proto*/

PyMODINIT_FUNC initascarray(void); /*proto*/
PyMODINIT_FUNC initascarray(void) {
  PyObject *__pyx_1 = 0;
  /*--- Libary function declarations ---*/
  __pyx_init_filenames();
  /*--- Module creation code ---*/
  __pyx_m = Py_InitModule4("ascarray", __pyx_methods, __pyx_mdoc, 0, PYTHON_API_VERSION);
  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  __pyx_b = PyImport_AddModule("__builtin__");
  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  /*--- Intern code ---*/
  if (__Pyx_InternStrings(__pyx_intern_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  /*--- String init code ---*/
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;};
  /*--- Builtin init code ---*/
  __pyx_builtin_IOError = __Pyx_GetName(__pyx_b, __pyx_n_IOError); if (!__pyx_builtin_IOError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 113; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_builtin_IndexError = __Pyx_GetName(__pyx_b, __pyx_n_IndexError); if (!__pyx_builtin_IndexError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_builtin_ValueError = __Pyx_GetName(__pyx_b, __pyx_n_ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1;}
  __pyx_skip_dispatch = 0;
  /*--- Global init code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  /*--- Type import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":16
 * """
 * 
 * import numpy             # <<<<<<<<<<<<<< 
 * 
 * # ==========================================================================
 */
  __pyx_1 = __Pyx_Import(__pyx_n_numpy, 0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 16; __pyx_clineno = __LINE__; goto __pyx_L1;}
  if (PyObject_SetAttr(__pyx_m, __pyx_n_numpy, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 16; __pyx_clineno = __LINE__; goto __pyx_L1;}
  Py_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":55
 *    int strlen(char *s)
 * 
 * import_array()             # <<<<<<<<<<<<<< 
 * 
 * # ==========================================================================
 */
  import_array();

  /* "/Users/users/terlouw/Python/Tables/ascarray.pyx":175
 *    return result
 * 
 * __version__ = '1.1'             # <<<<<<<<<<<<<< 
 */
  if (PyObject_SetAttr(__pyx_m, __pyx_n___version__, __pyx_k_4p) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1;}
  return;
  __pyx_L1:;
  Py_XDECREF(__pyx_1);
  __Pyx_AddTraceback("ascarray");
}

static char *__pyx_filenames[] = {
  "ascarray.pyx",
};

/* Runtime support code */

static void __pyx_init_filenames(void) {
  __pyx_f = __pyx_filenames;
}

static INLINE void __Pyx_RaiseArgtupleTooLong(
    Py_ssize_t num_expected,
    Py_ssize_t num_found)
{
    const char* error_message =
    #if PY_VERSION_HEX < 0x02050000
        "function takes at most %d positional arguments (%d given)";
    #else
        "function takes at most %zd positional arguments (%zd given)";
    #endif
    PyErr_Format(PyExc_TypeError, error_message, num_expected, num_found);
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list) {
    PyObject *__import__ = 0;
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    __import__ = PyObject_GetAttrString(__pyx_b, "__import__");
    if (!__import__)
        goto bad;
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    module = PyObject_CallFunction(__import__, "OOOO",
        name, global_dict, empty_dict, list);
bad:
    Py_XDECREF(empty_list);
    Py_XDECREF(__import__);
    Py_XDECREF(empty_dict);
    return module;
}

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result)
        PyErr_SetObject(PyExc_NameError, name);
    return result;
}

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
    Py_XINCREF(type);
    Py_XINCREF(value);
    Py_XINCREF(tb);
    /* First, check the traceback argument, replacing None with NULL. */
    if (tb == Py_None) {
        Py_DECREF(tb);
        tb = 0;
    }
    else if (tb != NULL && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto raise_error;
    }
    /* Next, replace a missing value with None */
    if (value == NULL) {
        value = Py_None;
        Py_INCREF(value);
    }
    #if PY_VERSION_HEX < 0x02050000
    if (!PyClass_Check(type))
    #else
    if (!PyType_Check(type))
    #endif
    {
        /* Raising an instance.  The value should be a dummy. */
        if (value != Py_None) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        /* Normalize to raise <class>, <instance> */
        Py_DECREF(value);
        value = type;
        #if PY_VERSION_HEX < 0x02050000
            if (PyInstance_Check(type)) {
                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
                Py_INCREF(type);
            }
            else {
                type = 0;
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception must be an old-style class or instance");
                goto raise_error;
            }
        #else
            type = (PyObject*) type->ob_type;
            Py_INCREF(type);
            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception class must be a subclass of BaseException");
                goto raise_error;
            }
        #endif
    }
    PyErr_Restore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}

static PyObject *__Pyx_UnpackItem(PyObject *iter, Py_ssize_t index) {
    PyObject *item;
    if (!(item = PyIter_Next(iter))) {
        if (!PyErr_Occurred()) {
            PyErr_Format(PyExc_ValueError,
                #if PY_VERSION_HEX < 0x02050000
                    "need more than %d values to unpack", (int)index);
                #else
                    "need more than %zd values to unpack", index);
                #endif
        }
    }
    return item;
}

static int __Pyx_EndUnpack(PyObject *iter) {
    PyObject *item;
    if ((item = PyIter_Next(iter))) {
        Py_DECREF(item);
        PyErr_SetString(PyExc_ValueError, "too many values to unpack");
        return -1;
    }
    else if (!PyErr_Occurred())
        return 0;
    else
        return -1;
}

static int __Pyx_InternStrings(__Pyx_InternTabEntry *t) {
    while (t->p) {
        *t->p = PyString_InternFromString(t->s);
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"

static void __Pyx_AddTraceback(char *funcname) {
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    PyObject *py_globals = 0;
    PyObject *empty_string = 0;
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    
    py_srcfile = PyString_FromString(__pyx_filename);
    if (!py_srcfile) goto bad;
    if (__pyx_clineno) {
        py_funcname = PyString_FromFormat( "%s (%s:%u)", funcname, __pyx_cfilenm, __pyx_clineno);
    }
    else {
        py_funcname = PyString_FromString(funcname);
    }
    if (!py_funcname) goto bad;
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    empty_string = PyString_FromString("");
    if (!empty_string) goto bad;
    py_code = PyCode_New(
        0,            /*int argcount,*/
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        empty_string, /*PyObject *code,*/
        __pyx_empty_tuple,  /*PyObject *consts,*/
        __pyx_empty_tuple,  /*PyObject *names,*/
        __pyx_empty_tuple,  /*PyObject *varnames,*/
        __pyx_empty_tuple,  /*PyObject *freevars,*/
        __pyx_empty_tuple,  /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        __pyx_lineno,   /*int firstlineno,*/
        empty_string  /*PyObject *lnotab*/
    );
    if (!py_code) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_Get(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = __pyx_lineno;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    Py_XDECREF(empty_string);
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* Type Conversion Functions */

static INLINE Py_ssize_t __pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}

static INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   if (x == Py_True) return 1;
   else if (x == Py_False) return 0;
   else return PyObject_IsTrue(x);
}

static INLINE PY_LONG_LONG __pyx_PyInt_AsLongLong(PyObject* x) {
    if (PyInt_CheckExact(x)) {
        return PyInt_AS_LONG(x);
    }
    else if (PyLong_CheckExact(x)) {
        return PyLong_AsLongLong(x);
    }
    else {
        PY_LONG_LONG val;
        PyObject* tmp = PyNumber_Int(x); if (!tmp) return (PY_LONG_LONG)-1;
        val = __pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static INLINE unsigned PY_LONG_LONG __pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
    if (PyInt_CheckExact(x)) {
        long val = PyInt_AS_LONG(x);
        if (unlikely(val < 0)) {
            PyErr_SetString(PyExc_TypeError, "Negative assignment to unsigned type.");
            return (unsigned PY_LONG_LONG)-1;
        }
        return val;
    }
    else if (PyLong_CheckExact(x)) {
        return PyLong_AsUnsignedLongLong(x);
    }
    else {
        PY_LONG_LONG val;
        PyObject* tmp = PyNumber_Int(x); if (!tmp) return (PY_LONG_LONG)-1;
        val = __pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}


static INLINE unsigned char __pyx_PyInt_unsigned_char(PyObject* x) {
    if (sizeof(unsigned char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        unsigned char val = (unsigned char)long_val;
        if (unlikely((val != long_val)  || (long_val < 0))) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to unsigned char");
            return (unsigned char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE unsigned short __pyx_PyInt_unsigned_short(PyObject* x) {
    if (sizeof(unsigned short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        unsigned short val = (unsigned short)long_val;
        if (unlikely((val != long_val)  || (long_val < 0))) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to unsigned short");
            return (unsigned short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE char __pyx_PyInt_char(PyObject* x) {
    if (sizeof(char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        char val = (char)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to char");
            return (char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE short __pyx_PyInt_short(PyObject* x) {
    if (sizeof(short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        short val = (short)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to short");
            return (short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE int __pyx_PyInt_int(PyObject* x) {
    if (sizeof(int) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        int val = (int)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to int");
            return (int)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE long __pyx_PyInt_long(PyObject* x) {
    if (sizeof(long) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        long val = (long)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to long");
            return (long)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed char __pyx_PyInt_signed_char(PyObject* x) {
    if (sizeof(signed char) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed char val = (signed char)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed char");
            return (signed char)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed short __pyx_PyInt_signed_short(PyObject* x) {
    if (sizeof(signed short) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed short val = (signed short)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed short");
            return (signed short)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed int __pyx_PyInt_signed_int(PyObject* x) {
    if (sizeof(signed int) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed int val = (signed int)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed int");
            return (signed int)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE signed long __pyx_PyInt_signed_long(PyObject* x) {
    if (sizeof(signed long) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        signed long val = (signed long)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to signed long");
            return (signed long)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}

static INLINE long double __pyx_PyInt_long_double(PyObject* x) {
    if (sizeof(long double) < sizeof(long)) {
        long long_val = __pyx_PyInt_AsLong(x);
        long double val = (long double)long_val;
        if (unlikely((val != long_val) )) {
            PyErr_SetString(PyExc_OverflowError, "value too large to convert to long double");
            return (long double)-1;
        }
        return val;
    }
    else {
        return __pyx_PyInt_AsLong(x);
    }
}
